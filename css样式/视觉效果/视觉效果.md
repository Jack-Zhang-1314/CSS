---
title: CSS视觉效果
date: 2021-2-8 1:8:30
author: Jack-zhang
categories: CSS
tags:
   - CSS
summary: css的视觉效果
---

## 投影

> 灵活使用`box-shadow`可以很好的做出各种投影效果

### [邻边投影]((01邻边投影.html))

* 准备一个初始化好的矩形

```css
.box1 {
  width: 20%;
  height: 20%;
  margin: 0 auto;
  background-color: goldenrod;
}
```

1. 在该元素的尺寸位置设置`box-shadow`
2. 将它向右下角和左下角下移一定距离,并对它进行模糊处理

```css
  box-shadow: 7px 6px 6px 0px rgb(0 0 0 / 50%);
```

### [单侧投影](01单侧投影.html)

>利用`box-shadow`的第四个参数,扩张半径去影响(会根据指定的值去扩张或者缩小)投影的尺寸
>
>举一个例子来说,一个-5px的扩张半径会把投影的宽度高度各减10px(每边各减5px)

* 只要移动顶侧,而不是左侧就可以借助扩张半径得到单侧的投影

```css
    box-shadow: 0px 8px 4px -2px rgb(0 0 0 / 50%);
```

### [双侧投影](01双侧投影.html)

> 扩张的半径在四个方向上的作用是均等的.也就是将`单侧投影`的技巧运用两次

```css
box-shadow: 0px 8px 4px -2px rgb(0 0 0 / 50%),
        0px -8px 4px -2px rgb(0 0 0 / 50%);
```

### [不规则投影](01不规则投影.html)

>当给一个矩形或者其它`border-radius`生成的形状加投影时,`box-shadow`表现的都很完美.但是如果添加了一些伪元素或者半透明的装饰之后,就很难做到,`box-shadow`会忽视透明部分

1. 透明图像,背景图像,或者`border-image`
2. 元素设置了点状,虚线或者半透明边框,但没有背景
3. 伪元素,对话气泡的小尾巴
4. 所有的切角形状
5. 所有的折角形状
6. 通过`clip-path`生成的形状,比如菱形图片

>`drop-shadow()`滤镜可以接收的参数和`box-shadow`是一样的,<span style="color:red">不包括扩张半径,inset关键字,也不支持逗号分割的多层投影语法</span>

* 当给`clip-path`生成的形状时,最好给外面包一层div
* `text-shadows`也可以通过`drop-shadow()`滤镜来产生投影

## 染色效果

>为一组图片增加染色效果,可以使风格迥异的图片达到一致的的效果

### [滤镜](02染色.html)

1. `sepia()`:使照片为棕褐色;`100%`是完全的棕褐色,0%没有变化,呈线性变化
2. `hue-rotate()`:色调,单位`deg/turn`.正值增加色调,负值减少色调.每360°是一个轮回
3. `saturate()`:饱和度.值越大饱和度越高,值为0,无饱和度(灰色)

### 混合模式

>使用滤镜得到很亮的颜色,多数像褪了色一样.并且使用`saturate()`滤镜时,有一种不自然,过度风格化的效果

* **混合模式**:控制上层元素的颜色与下层颜色进行混合的方式.用它来实现染色效果时,需要使用的混合模式是`luminosity`,会保留上层元素的`HSL`亮度信息,并从他的下层吸取色相和饱和度信息

1. 第一种:把图片包裹在一个容器里,并且把容器的背景色设置为我们想要的主色调

   ```html
   <div class="box">
     <img src="./img/0.jpg" alt="">
   </div>
   ```

   ```css
       .box {
      height: 100%;
      width: 100%;
      background: hsl(34, 51%, 38%);
    }

    img {
      height: 100%;
      width: 100%;
      background-size: contain;
      mix-blend-mode: luminosity;
    }
   ```

2. 第二种:不用图片,使用\<div>元素---把这个元素的第一层设置为要染色的图片,第二层设置为想要的主色调

```css
.box {
  height: 100%;
  width: 100%;
  background-image: url(./img/0.jpg);
  background-size: cover;
  background-color: hsl(34, 51%, 38%);
  background-blend-mode: luminosity;
  transition: .5s background-color;
}
.box:hover {
  background-color: transparent;
}
```

```html
<div class="box"></div>
```

## [毛玻璃](03毛玻璃.html)

### 初始化

```html
<div class="container">
  <div class="content">
    <h1>WARFRAME</h1>
    <p>The Grineer, with their endless clone armies, have plunged the system into chaos. There is only one force that
      can match them, you.
      You are Tenno, an ancient warrior, a master of gun and blade. You wield the mighty Warframes and command their
      awesome powers. Forge your weapons. Gather like-minded Tenno and take the fight back to the Grineer. The Origin
      System needs you once again. Are you ready?</p>
  </div>
</div>
```

```css
* {
  margin: 0%;
  padding: 0%;
}
html,
body {
  height: 100%;
  width: 100%;
  font-size: 1.2rem;
}
.container {
  height: 100%;
  width: 100%;
  background: url("./img/0.jpg");
  background-size: cover;
  overflow: hidden;
}
h1 {
  text-align: center;
}
.content {
  width: 40rem;
  height: 20rem;
  margin: 0 auto;
  margin-top: 15rem;
  padding: 2rem;
}
```

### 一点点思考

>毛玻璃效果会用到css滤镜`filter`中的`blur()`属性,传入css像素,值越大越模糊
>
>参考:<https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter>

* 首先想到在contain中加入透明度并使用模糊滤镜

```css
.content{
  filter: blur(0.125rem);
  background-color: rgba(0, 0, 0, 0.3);
}
```

1. 但是这种效果内容也会模糊掉,为了保证文字不会模糊需要单独加一个应用层模糊效果
2. 模糊效果并不会用到其背后的元素,所以使用content区域要和背景相同的区域进行模糊

#### 伪元素

>第一个方式就是添加伪元素(但是有一个问题就是伪元素不能使用width,height继承宿主元素的尺寸)

1. 在`.content`中加入相对定位
2. 为了使伪元素位于 content 的下面这里给其设置`z-index:-1`，为不使其隐藏到背景图的后面，这里给 content 设置 `z-index:1`

  ```css
  .container{
    position: relative;
    z-index:1;
  }
  .content::after {
  content: "";
  position: absolute;
  left: 0%;
  top: 0%;
  right: 0%;
  bottom: 0%;
  background-color: rgba(0, 0, 0, 0.3);
  background-size: cover;
  z-index: -1;
  }
  ```

3. 加下来设置相同的背景图并设置滤镜

   ```css
   .content::after{
      background-image: url("./img/0.jpg");
      filter: blur(10px);
   }
   ```

> 处理到现在中间的部分的图和大背景还是没有很好的拼接成功

#### 模糊处理

>对伪元素进行模糊处理,使用`background-attachment: fixed;`

```css
.content::after{
  background-attachment: fixed;
}
```

* 这样就可以达到基本的效果

### backdrop-filter

> `background`与`filter`语法完全一致
>> 唯一不同的就是,`background`让当前元素所在区域**后面的内容**模糊灰度或高亮之类
>>
>>`filter`是让当前元素自身模糊灰度或高亮等

```css
/* 关键字值 */
backdrop-filter: none;

/* URLd方式外链SVG filter */
backdrop-filter: url(zxx.svg#filter);

/* <filter-function>值 */
backdrop-filter: blur(2px);
backdrop-filter: brightness(60%);
backdrop-filter: contrast(40%);
backdrop-filter: drop-shadow(4px 4px 10px blue);
backdrop-filter: grayscale(30%);
backdrop-filter: hue-rotate(120deg);
backdrop-filter: invert(70%);
backdrop-filter: opacity(20%);
backdrop-filter: sepia(90%);
backdrop-filter: saturate(80%);
```

| 滤镜        | 释义     |
| ----------- | -------- |
| blur        | 模糊     |
| brightness  | 亮度     |
| contrast    | 对比度   |
| drop-shadow | 投影     |
| grayscale   | 灰度     |
| hue-rotate  | 色调变化 |
| invert      | 反相     |
| opacity     | 透明度   |
| saturate    | 饱和度   |
| sepia       | 褐色     |

#### 使用backdrop-filter

>* 使用backdrop-filter很容易达到毛玻璃效果,并且不需要伪元素.
>* 只需要在原来基础上加上`backdrop-filter: blur(23px);`

```css
.content {
  backdrop-filter: blur(23px);
}
```
